# 端侧狗吠声纹验证系统使用指南

## 系统概述

本指南介绍如何使用基于i-vector算法的单类狗声纹验证系统，该系统专为端侧部署优化，能够在户外和家庭环境中可靠识别特定狗的吠叫声。

## 系统特点

- **传统机器学习方法**：不依赖深度学习，适合资源受限的端侧设备
- **单类验证设计**：专门优化用于验证"是否是目标狗"的场景
- **噪声鲁棒性**：内置多种音频预处理技术，适应户外和家庭环境下的噪声干扰
- **端侧优化**：模型轻量化，计算复杂度低，内存占用小
- **可调节阈值**：支持根据应用场景调整验证严格程度

## 快速开始

### 环境配置

系统依赖以下Python库：

```bash
pip install numpy librosa scikit-learn scipy
```

### 基本工作流程

1. 收集目标狗的注册音频
2. 训练系统
3. 保存模型
4. 使用模型进行验证

## 详细使用步骤

### 1. 数据准备

#### 注册数据要求

- 收集**5-10个**目标狗的吠叫音频样本
- 每个样本时长**2-5秒**，包含清晰的狗吠声
- 尽量在不同环境下录制（室内、室外、不同距离等）以提高鲁棒性
- 音频格式：**.wav**文件，采样率16kHz最佳

示例目录结构：

```
enroll_dog_max/
  ├── bark1.wav
  ├── bark2.wav
  ├── bark3.wav
  ├── bark4.wav
  └── bark5.wav
```

#### 测试数据准备

对于阈值调优，建议准备：
- 目标狗的额外测试音频（5-10个）
- 其他狗的音频样本（10-20个）

### 2. 系统配置与初始化

```python
from one_class_dog_verification import OneClassDogIVectorSystem

# 初始化验证系统
system = OneClassDogIVectorSystem(
    dog_name="max",        # 目标狗的名称
    n_components=2,        # GMM分量数（端侧建议1-4）
    tv_dim=8,              # i-vector维度（端侧建议5-15）
    reg_covar=1e-4,        # 协方差矩阵正则化参数
    threshold=0.4          # 初始验证阈值
)
```

**端侧部署参数建议**：
- 资源非常受限的设备：`n_components=1`, `tv_dim=5`
- 中等资源设备：`n_components=2`, `tv_dim=8`
- 资源较丰富设备：`n_components=4`, `tv_dim=12`

### 3. 训练系统

```python
# 准备注册音频文件列表
enroll_dir = "./enroll_dog_max"
enroll_files = [os.path.join(enroll_dir, f) for f in os.listdir(enroll_dir) if f.lower().endswith('.wav')]

# 训练系统
system.train(enroll_files)
```

训练过程中，系统会：
- 预处理每个注册音频（噪声抑制、信号增强）
- 提取鲁棒的MFCC特征
- 训练简化的GMM-UBM模型
- 估计total variability矩阵
- 提取并保存目标狗的i-vector模板

### 4. 保存和加载模型

```python
# 保存模型到默认路径
system.save_model()

# 或保存到指定路径
system.save_model("models/my_custom_model.pkl")

# 加载已训练的模型
loaded_system = OneClassDogIVectorSystem.load_model("models/my_custom_model.pkl")
```

### 5. 进行验证

```python
# 验证单个音频文件
test_file = "./test_audio/unknown_bark.wav"
result = system.verify(test_file)

# 输出验证结果
print(f"验证结果: {result['message']}")
print(f"相似度分数: {result['similarity']:.4f}")
print(f"置信度: {result['confidence']:.4f}")
print(f"使用阈值: {result['threshold']}")
```

验证结果包含以下字段：
- `is_target`: 布尔值，表示是否是目标狗
- `similarity`: 相似度分数（范围：-1到1）
- `threshold`: 使用的验证阈值
- `confidence`: 置信度（范围：0到1）
- `message`: 可读性强的结果描述

### 6. 调整验证阈值

根据应用场景，您可能需要调整验证阈值以平衡误拒率(FRR)和误纳率(FAR)：

```python
# 准备正样本和负样本
test_positive_files = ["path/to/max_bark1.wav", "path/to/max_bark2.wav", ...]
test_negative_files = ["path/to/other_dog1.wav", "path/to/other_dog2.wav", ...]

# 调整阈值，目标误拒率为10%
threshold_result = system.tune_threshold(
    test_positive_files,
    test_negative_files,
    target_frr=0.1  # 目标误拒率10%
)

print(f"新阈值: {threshold_result['threshold']:.4f}")
print(f"实际误拒率: {threshold_result['frr']:.4f}")
print(f"实际误纳率: {threshold_result['far']:.4f}")
```

**阈值调整建议**：
- 高安全性场景（不希望误判其他狗为目标狗）：设置较高阈值（如0.6-0.8）
- 便利性优先场景（减少目标狗被误拒的情况）：设置较低阈值（如0.3-0.5）
- 平衡场景：使用`tune_threshold`自动调整阈值

## 环境适应与优化

### 户外环境优化

在户外嘈杂环境中，建议：

1. 增加预加重系数（在源码`preprocess_audio`函数中调整）：
   ```python
y = np.append(y[0], y[1:] - 0.98 * y[:-1])  # 增加到0.98增强高频
```

2. 强化噪声抑制：
   ```python
# 增加噪声抑制系数（从1.5增加到2.0）
magnitude = np.maximum(magnitude - 2.0 * noise_magnitude, 0.1 * magnitude)
```

3. 调整验证阈值：降低阈值以减少户外环境下的误拒率

### 家庭环境优化

在家庭安静环境中，建议：

1. 降低预加重系数：
   ```python
y = np.append(y[0], y[1:] - 0.95 * y[:-1])  # 降低到0.95
```

2. 适度噪声抑制：
   ```python
# 降低噪声抑制系数（从1.5减少到1.2）
magnitude = np.maximum(magnitude - 1.2 * noise_magnitude, 0.1 * magnitude)
```

3. 提高验证阈值：增加阈值以提高识别精度

## 端侧部署建议

### 模型简化

对于资源极其受限的设备，可进一步简化模型：

- 将GMM分量数降至1：`n_components=1`
- 将i-vector维度降至5：`tv_dim=5`
- 使用更紧凑的特征表示（修改`extract_mfcc_robust`函数）

### 计算优化

- 预处理中减少FFT点数（从512减少到256）
- 减少特征帧数要求（从8帧减少到5帧）
- 使用更高效的序列化格式替代pickle

### 内存优化

- 释放不需要的中间变量
- 避免一次性加载过多音频文件
- 使用增量式训练（如需）

## 故障排除

### 常见问题及解决方案

1. **问题**：训练失败，提示"没有有效的注册音频用于训练"
   **解决方案**：确保注册目录中包含至少一个有效的.wav文件，且文件长度足够

2. **问题**：验证结果不稳定
   **解决方案**：增加注册样本数量，确保样本覆盖不同的吠叫类型和环境

3. **问题**：在噪声环境下性能下降
   **解决方案**：调整噪声抑制参数，或重新在目标环境中收集注册样本

4. **问题**：模型文件过大，不适合端侧部署
   **解决方案**：减少GMM分量数和i-vector维度，使用协议4的pickle格式

## 示例代码

以下是完整的端侧部署示例：

```python
import os
from one_class_dog_verification import OneClassDogIVectorSystem

# 配置
DOG_NAME = "rex"
MODEL_PATH = "models/tiny_ivector_model.pkl"
THRESHOLD = 0.45

# 初始化函数（设备启动时调用一次）
def init_verification_system():
    try:
        # 尝试加载已训练的模型
        if os.path.exists(MODEL_PATH):
            print("加载已训练的模型...")
            system = OneClassDogIVectorSystem.load_model(MODEL_PATH)
            return system
        else:
            print("模型文件不存在，请先训练模型")
            return None
    except Exception as e:
        print(f"初始化系统失败: {str(e)}")
        return None

# 验证函数（实际使用时调用）
def verify_dog_bark(system, audio_file):
    try:
        if system is None:
            return False, "系统未初始化"
            
        # 执行验证
        result = system.verify(audio_file)
        
        # 根据结果返回布尔值和消息
        return result['is_target'], result['message']
        
    except Exception as e:
        print(f"验证过程出错: {str(e)}")
        return False, f"验证失败: {str(e)}"

# 使用示例
if __name__ == "__main__":
    # 初始化系统
    verification_system = init_verification_system()
    
    if verification_system:
        # 待验证的音频文件
        test_audio = "./capture_bark.wav"
        
        # 执行验证
        is_target, message = verify_dog_bark(verification_system, test_audio)
        
        # 输出结果
        print(f"验证结果: {message}")
        
        # 根据结果执行相应操作
        if is_target:
            print("执行目标狗响应操作...")
            # 这里可以添加控制逻辑，如点亮LED、播放声音等
        else:
            print("忽略非目标狗声音")
```

## 性能评估

系统性能可通过以下指标评估：

- **准确率**：正确验证的比例
- **误拒率(FRR)**：目标狗被错误拒绝的比例
- **误纳率(FAR)**：非目标狗被错误接受的比例
- **等错误率(EER)**：当FRR=FAR时的错误率

建议在部署前，在目标环境中使用足够的样本进行全面测试和评估。

## 进一步改进方向

1. **自适应阈值**：根据环境噪声水平动态调整验证阈值
2. **分段验证**：将长音频分段验证后综合判断
3. **狗吠检测前置**：增加专门的狗吠检测模块，减少非狗吠声音的干扰
4. **模型量化**：对模型参数进行量化，进一步减少内存占用
5. **特征降维**：探索更高效的特征表示方法